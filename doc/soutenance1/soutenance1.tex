%%%%%%%%%%%%%%%%%%%%%% Props %%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{eurosym}
\usepackage{color}
\usepackage{soul}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{enumerate}

\pagestyle{fancy}
\lhead{Cahier des charges}
\chead{Deadly Science}
\rhead{Custos Carceris}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
  commentstyle=\color{mygreen},
  keywordstyle=\color{blue},       % keyword style
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  stringstyle=\color{mymauve},     % string literal style
  language=[Sharp]C,                 % the language of the code
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  tabsize=2,	                   % sets default tabsize to 2 spaces
  showstringspaces=false,
  numbers=left,
}

\begin{document}


%%%%%%%%%%%%%%%%%%%%%% Titre %%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
	\centering
	{\scshape\LARGE Custos Carceris\par}
	\vspace{1cm}
	{\scshape\Large Première soutenance \par}
	\vspace{1.5cm}
	{\huge\bfseries Deadly Science\par}
	\vspace{2cm}
	\includegraphics[width=0.5\textwidth]{logo.png}\par\vspace{1cm}
	{\Large\itshape Léandre Perrot\par}
	{\Large\itshape Yann Boudry\par}
	{\Large\itshape Steve Suissa\par}
	{\Large\itshape Célian Raimbault\par}
	\vfill
	Un projet EPITA
	\vfill
	{\large \today\par}
\end{titlepage}



\newpage
\tableofcontents


%%%%%%%%%%%%%%%%%%%%% Intro %%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Introduction}

Le jeu a grandement avancé depuis le retour du cahier des charges : le réseau est quasiment entièrement fonctionnel, pareil pour la caméra, le site avance petit à petit, la génération est presque fini et certaines musiques ont été composées. Globalement, le jeu est quasiment jouable.
\begin{table}[!h]
\centering
\caption{Avancement}
\begin{tabular}{|l|l|l|}
\hline

Tâches $\backslash$Soutenances & Attendu & Réalité \\ \hline
Camera & 50\% & 75\% \\ \hline
G Joueur & 30\% & 50\% \\ \hline
G Jeu & 30\% & 30\% \\ \hline
Reseau & 50\% & 75\% \\ \hline
Map Const & 30\% & 30\% \\ \hline
Menu & 15\% & 70\% \\ \hline
Chrono/GUI & 30\% & 30\% \\ \hline
Site TXT & 0\% & 30\% \\ \hline
Site E & 0\% & 0\% \\ \hline
Map Gen & 0\% & 50\% \\ \hline
Musique & 0\% & 25\% \\ \hline
Sons & 0\% & 10\% \\ \hline

\end{tabular}
\end{table}
 
\newpage
\section{Réalisations}

%%%%%%%%%%%%%%%%%%%%%% Yann %%%%%%%%%%%%%%%%%%%%%%

\subsection{Yann Boudry}

\subsubsection{Menu Principal}

Le menu est la première image qu'aperçoit le joueur du jeu. Il est important d'avoir un menu bien réalisé et qui donne envie de jouer à l'utilisateur.

\par\vspace{0.5cm}
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.8\textwidth]{MainMenu.png}
    \caption{Menu Principal}
    \label{Main Menu}
\end{figure}{}

\paragraph{Menu}

J'ai choisi de faire un menu simple qui comporte les fonctionalité essentielles que l'on attend de cette partie du jeu. Il comporte donc trois boutons:

\begin{itemize}
    \item Jouer, qui comme il l'indique permet de lancer une partie.
    \item Paramètres, qui là encore ouvre une fenêtre de paramètres.
    \item Quitter, comme son nom l'indique, il arrête l'application.
\end{itemize}

\subsubsection{Jouer}

\paragraph{}
Ce premier bouton vous approche d'un pas de plus vers l'épreuve de survie où tous les coups sont permis: Deadly Science. Après vous être lancé dans l'aventure apparaît un deuxième menu qui regroupe les différents laboratoires abandonnés de Deadly Science. Vous pouvez rejoindre un groupe partant pour une destination connue, ou bien-sûr en chercher un nouveau et l'explorer avec votre équipe. Mais gare aux maladies qui peuvent être... Mortelles!
\paragraph{} Si l'aventure vous effraie trop, vous pouvez toujours revenir en arrière pour parfaire la maîtrise de votre personnage au sein des paramètres ou tout simplement quitter le jeu.

\subsubsection{Paramètres}
Cette partie concerne les paramètres du jeu, pour l'instant ne comprenant qu'un gestionnaire de touches pour les différents mouvements (avant, arrière, gauche, droite, sauter).

\paragraph{Principe}
Unity propose un gestionnaire de touches mais il faut pour cela avoir le projet et l'éxecuter dans Unity.
Il est impossible de changer les touches une fois que le jeu est lancé. J'ai donc cherché des manières de remédier à ce problème.

\paragraph{Implémentation}

\subparagraph{Rebind}
Rien de plus énervant que de lancer son jeu favori mais de devoir réassigner les touches de son clavier à chaque fois. Afin d'empêcher toute destruction inopinée de materiel informatique j'ai écrit un script pour cela: InputManager. Il rassemble les touches utilisées et enregistrées, une fonction retournant la/les touches enfoncées, une autre retournant la touche associée à l'action demandée pour l'affichage et le changement de touches.
\newline Pour gérer et enregistrer les touches, j'ai utilisé un dictionaire de string/Keycode auquel j'attribue des valeurs par défaut dès que le script est appelé:

\begin{itemize}
    \item Jump => Espace
    \item Forward => W
    \item Backward => S
    \item Left => A
    \item Right => D
\end{itemize}

J'ai opté pour l'utilisation des PlayerPrefs pour la sauvegarde des touches car c'est une classe très facile à manipuler. Elle ne permet de stocker que des string, float ou int mais la conversion est très simple puisqu'il est possible de convertir les Keycodes en un int unique à l'aide d'un simple cast.
\newline Le script va ensuite tester l'existence de PlayerPrefs sur l'ordinateur de l'utilisateur auquel cas les touches prendront ces valeurs.

\par\vspace{0.2cm}
\begin{lstlisting}
    for (int i = 0; i < buttonKeys.Count; i++)
        {
            if (PlayerPrefs.HasKey(keys[i]))
                buttonKeys[keys[i]] = 
                    (KeyCode) PlayerPrefs.GetInt(keys[i]);
        }
\end{lstlisting}

Finalement, on sauvegarde les touches. (Utile seulement lors d'un premier lancement du jeu)

\subparagraph{En jeu}
J'ai également du refaire une fonction qui teste quand les touches sont enfoncées. Pour éviter de devoir changer les touches dans tout le code à chaque modification, elle prend le nom de l'action en argument et retourne l'état de la touche correspondante grâce au dictionnaire.

\subparagraph{Affichage}
Le panneau de paramètres utilise un script KeybindDialog qui récupère les noms des touches à partir de l'InputManager. Il va ensuite instancier un préfab pour chaque touche, constitué du nom de l'action et d'un bouton avec la touche correspondante. Lorsque ce bouton est appuyé il va écouter tout le clavier et réassigner la première touche enfoncée à l'action demandée. Le changement est sauvegardé sur l'ordinateur avec les PlayerPrefs en simultané pour la prochaine utilisation.

\subsubsection{Pause}

\par\vspace{0.5cm}
\begin{figure}[!h]
    \centering
    \includegraphics[width=1\textwidth]{Pause.PNG}
    \caption{"Pause"}
    \label{Pause}
\end{figure}{}

Un jeu n'existe pas sans son menu pause. Enfin... la pause dans un jeu en ligne est discutable.
On y retrouve les paramètres pour changer les touches enrichies d'un bouton quitter pour abandonner ses frères d'armes à leur sort et revenir au chaud du menu principal.

\newpage
\subsubsection{Écran de fin}

L'écran de fin permet de conclure la partie et dire au joueur s'il a gagné ou perdu.

\paragraph{Victoire ou Défaite}
\subparagraph{}
J'ai utilisé deux panneaux, un pour la victoire, écrit en vert, et l'autre pour la défaite, en rouge.
Les deux sont munis d'un bouton "quitter" centré qui permet de revenir au menu principal.
La caméra n'est pas bloquée, le joueur peut donc continuer à regarder autour de lui, cependant les mouvements eux sont désactivé.

\par\vspace{0.5cm}
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.45\textwidth]{Victoire.PNG}
    \includegraphics[width=0.45\textwidth]{Defaite.PNG}
    \caption{Victoire et Défaite}
    \label{Ecran de fin}
\end{figure}{}

\subparagraph{}
Les deux panneau sont activé de base afin de pouvoir les sauvegarder pour afficher le bon à la fin de la partie. Ils sont ensuite immédiatement désactivé avant le début du jeu.Pour déterminer si chaque joueur à gagné ou perdu je compare l'état du joueur au début et à la fin de la phase 2 (ou les infectés cherchent à se venger des sains). La comparaison est simple puisqu'il n'y a plus de sérum, les infectés ne peuvent plus changer d'état, seul les sains peuvent devenir infectés. Ainsi si l'état a changé, c'est que le joueur sain a perdu, sinon il a survécu.
%%%%%%%%%%%%%%%%%%%%%% Leandre %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% Celian %%%%%%%%%%%%%%%%%%%%%%

\newpage
\subsection{Célian Raimbault}

Dans ce projet, je suis chargé d'implémenter en priorité le comportement des joueurs, la musique et les effets. Pour cette soutenance, je me suis concentré exclusivement sur le joueur car la musique et les effets serviront à rendre plus agréable le jeu une fois que nous aurons implémenté la base du jeu, c'est-à-dire principalement le réseau avec le contrôle du joueur

\subsubsection{Gameplay du joueur}

Le gameplay du joueur est un des points les plus importants du jeu, de plus, il est important de commencer ce projet avec celui-ci. Cette partie se décompose en deux sous parties, la gestion de la physique ainsi que l'interaction entre le joueur et l'environnement.

\paragraph{Gestion de la physique}

La physique du joueur est la première chose à implémenter car sans elle il n'y aurait pas de mouvements des joueurs et encore moins d'interaction.
De plus, cette partie doit être réalisée avec minutie car elle peut radicalement changer le gameplay si elle est bien (ou mal) réalisée.

\subparagraph{Les physiques de Unity}

Unity dispose d'un moteur physique, c'est lui que nous utilisons car il est très complet et adapté pour notre jeu. En effet, ce moteur physique nous permet d'appliquer des forces sur des objets, de tester si plusieurs objets sont en collision et même de définir des couches permettant de filtrer les collisions entre objets. Dans Unity, un objet peut avoir un corps s'il est dynamique (c'est-à-dire qu'il réagit à des forces extérieures) avec une ou plusieurs boites de collision.

\subparagraph{Principe}

En premier temps, j'ai pensé à définir le joueur avec un RigidBody et une boite de collision en forme de capsule, c'est-à-dire que le joueur est attiré vers le bas par la gravité et a une forme de capsule pour éviter de bouger quand il tourne et pour mieux pouvoir grimper sur des objets en sautant. Pour bouger le joueur, il suffit de tester à chaque mise à jour du jeu si une entrée clavier est appuyée et appliquer une force. Finalement, après avoir implémenté ce mécanisme je me suis rendu compte que Unity disposait également d'un composant nommé PlayerController et qu'il était peut-être plus adapté au jeu. En effet, le CharacterController remplace le RigidBody du joueur, il permet d'entièrement contrôler le joueur, c'est-à-dire que c'est le rôle du développeur de gérer les physiques comme les forces appliquées sur le corps. Le CharacterController prend juste en charge les collisions entre les autres objets pour ne pas passer au travers. Il est préférable d'utiliser ce composant car nous pouvons par exemple enlever la gravité ou les forces de friction quand nous le voulons. Il est utilisé également pour éviter des bugs causés par le réseau, si deux joueurs sont au même endroit, il ne faut pas les éjecter.

\subparagraph{Implémentation}

J'ai ainsi déclaré un attribut \emph{velocity} au joueur qui est sa vitesse et ajoute une force de gravité à celui-ci. À chaque mise à jour du jeu, cette variable s'ajoute à la position du joueur, elle est juste multipliée par le temps qui s'est écoulé entre la dernière mise à jour pour que le mouvement soit fluide.
Les mouvements se font presque de la même manière qu'avec un RigidBody, quand il y a une entrée active, on ajoute à \emph{velocity} une force proportionnelle au temps de pression orientée vers la direction voulue.

\begin{lstlisting}
Vector3 movements = x * transform.right + z * transform.forward;
\end{lstlisting}

 Il y a également une variable \emph{maxSpeed} qui est la limite de vitesse, si le joueur dépasse cette limite il ne peut que freiner son mouvement, c'est-à-dire que le produit scalaire entre \emph{velocity} et \emph{mouvement} doit être négatif pour mettre à jour la vitesse.

\emph{(Voir annexe [\ref{Mouvements}])}

Pour pouvoir sauter, il a fallu tester si le joueur touchait sol. Pour cela, j'ai ajouté un objet vide qui décrit la position de détection du sol comme ça le joueur test si le sol est présent dans une petite sphère autour de ce point.

\begin{lstlisting}
bool grounded = velocity.y <= .1f &&
	Physics.CheckSphere(groundSensor.position, controller.radius, groundMask);
\end{lstlisting}

Il faut ajouter une force de frottements (provenant de l'air ou du sol) pour que le jeu soit jouable, sinon notre joueur ne s'arrêtera pas. Bien sûr, cette force est appliquée seulement si le joueur n'avance pas.

\emph{(Voir annexe [\ref{Friction}])}

Il est évident que le joueur n'est pas censé pouvoir grimper sur un autre joueur ou même sauter depuis un objet qui n'entre pas en collision avec lui. C'est pour cela que j'ai mis en place le système de couches physiques. Il y a, en plus de celles fournies par défaut par Unity, les couches :

\begin{itemize}
\item Player : Seulement pour les joueurs.

\item Walls : Pour la détection du sol ou des murs.

\item PowerUps : Ils ne touchent que les joueurs en tant que \emph{trigger}, c'est-à-dire que le joueur passe néanmoins au travers.
\end{itemize}

\paragraph{Interaction joueur / environnement}

L'environnement comprend les sérums mais aussi les autres joueurs, le comportement des sérums face au joueur est plutôt simple alors commençons par celui-ci.

\subparagraph{Sérums}

Nous avons pensé qu'il serait envisageable d'ajouter des power ups à notre jeu une fois que celui-ci sera plus complet, un sérum peut être considéré comme un power up car c'est un objet qui peut se faire collecter par un joueur. Pour éviter de changer beaucoup de scripts si nous ajoutons des power ups j'ai pensé à utiliser de la programmation orientée objet en créant une classe PowerUp qui est abstraite, elle possède une méthode \emph{OnCollect} qui est appelée lors d'une collision avec un joueur, elle prend en paramètre le joueur et retourne si le power up doit être détruit. Il ne doit pas toujours se détruire car un joueur ayant déjà collecté un sérum ne peut pas en prendre en autre. Le sérum utilise alors cette fonction dans sa propre classe.


\begin{lstlisting}
protected abstract bool PowerUp.OnCollect(GameObject player);
\end{lstlisting}

\paragraph{Joueur et réseau}

Le joueur est un des éléments les plus utilisés en réseau, sa position doit être synchronisée mais pas seulement, il faut prévenir chaque joueur quand un joueur change de statut ou même se fait toucher par un autre joueur. Unity utilise des composants attribués aux objets en jeu, nous pouvons en mettre plusieurs pour un seul objet et c'est cela que nous allons faire pour le joueur. Le but est d'enlever les composants inutiles, par exemple, un joueur contrôlera un seul joueur en jeu donc le module gérant les mouvements du joueur sera retiré pour les joueurs non contrôlés. Ceci permet également de préparer le joueur dans une unique prefab en ajoutant tous les modules avec les bonnes propriétés.

Cette partie est particulièrement compliquée à imaginer quand on ne s'y connait pas bien en réseau, c'est pour cela qu'il est possible que certaines classes soient modifiées lors d'une future soutenance.

\subparagraph{Classes du joueurs}

\begin{itemize}

\item PlayerNetwork : Permet de gérer les événements liés au réseau et également mets en place ou retire toutes les autres classes du joueur. Ce script est toujours présent sur un joueur.

\item Player : Classe permettant de contrôler le joueur. Utilisée quand le joueur est contrôlé par le client.

\item PlayerState : Classe gérant le statut du joueur. La classe est toujours présente, ses attributs se font modifier seulement par le réseau.

\item PlayerMaster : Dispose de fonctions gérant le jeu et les phases. Ce module est présent si le joueur est contrôlé par le client ainsi que le client est le maître de jeu.

\item PlayerSlave : Conçue pour recevoir les appels de PlayerMaster. Présent si le joueur est contrôlé par le client mais, contrairement à PlayerMaster, le client n'est pas le maître de jeu.

\end{itemize}

\subparagraph{PlayerNetwork}

Il est important que chaque module d'un joueur soit coordonné avec les autres. Par exemple, si le réseau possède un problème et qu'un joueur se connecte en plusieurs secondes, il faut l'attendre, ensuite préparer le jeu (ce qui comprend la génération du labyrinthe) puis enfin lancer la première phase. Il ne faut pas non plus qu'un joueur puisse bouger avant que le réseau soit initialisé.
Pour cela, les modules du joueur n'ont pas de fonction Start ou Update, sauf PlayerNetwork qui possède une fonction Start et Player qui possède une fonction Update. Dans PlayerNetwork.Start, nous appelons chaque fonction StartAfterNetwork de chaque module pour éviter les problèmes de synchronisation.
Chaque joueur instancié s'enregistre via PlayerNetwork.RegisterPlayer pour pouvoir lancé le jeu une fois que chaque joueur est présent.

\emph{(Voir annexe [\ref{NetA}])}

En addition, lors d'une collision joueur - joueur il faut qu'un seul joueur 'résolve' la collision, c'est-à-dire qu'il doit décider du nouveau statut de chacun et informer les joueurs par le réseau de ce nouveau statut.
Pour implémenter cela, j'ai décidé de créer un identifiant unique pour chaque joueur, puis créé une fonction HasPriority qui va décider quel joueur va avoir la priorité suivant cet identifiant.

\emph{(Voir annexe [\ref{NetB}])}

\newpage
\subsubsection{Gameplay dans le jeu}

Le gameplay dans le jeu comprend les phases de jeu.

\paragraph{Phases}

Voici les phases que peut avoir un joueur :

\begin{itemize}
\item Infecté : La première phase, le joueur doit collecter un sérum

\item Guéri : La seconde phase si le joueur a pris un sérum

\item Corrompu : La seconde phase quand le joueur est celui qui n'a pas collecté de sérum

\item Fantôme : Cette phase est celle que prendra un joueur ayant perdu, il pourra plus tard voir la partie sans déranger les joueurs en jeu.
\end{itemize}

Pour implémenter ces phases, il suffit de créer une enum dans la classe de joueur avec un setter qui va mettre à jour d'autres composants du joueur comme la couleur du nom et également d'autres objets du jeu, il faut avertir les autres joueurs et le jeu de ce statut.\emph{(Voir annexe [\ref{PhaseA}])}

Quand un joueur entre en collision avec un autre joueur, si la phase est différente nous devons changer le statut des joueurs pour pouvoir infecter un joueur par exemple. Ce changement de statut a lieu également quand un joueur donne un coup à un autre joueur, seulement, si les phases sont les mêmes, alors nous allons changer l'endurance du joueur.

\paragraph{Endurance}

Pour que les joueurs puissent interagir entre eux même s'ils sont dans la même phase, nous avons pensé à intégrer une jauge d'endurance. Cette jauge se remplit au fur et à mesure du temps. Quand un joueur donne un coup à un autre joueur, celui-ci perd de l'endurance, une fois à zéro, le joueur est comme "sonné", ces mouvements sont ralentis et le saut est désactivé. En étant sonné, un joueur ne peut pas reprendre de coup.

\begin{lstlisting}
if (sameStatus)
    if (!stunned)
        Stamina -= strength;

// Tests status...
\end{lstlisting}

\newpage
\subsubsection{Modèle et animations}
Certaines rumeurs indiquant que les examinateurs de projets s'étaient lassés des joueurs en forme de cube lors de la première soutenance nous ont obligés d'implémenter un prototype de modèle de joueur ainsi que des animations allant avec. Pour l'instant, nous avons décidé d'utiliser des ressources créées par d'autres utilisateurs disponibles gratuitement sur l'Asset Store d'Unity. Intégrer cela se fait en deux temps, importer le modèle et l'animer puis ensuite jouer les bonnes animations et transitions à l'aide de scripts.
\paragraph{Animation du modèle}

Unity dispose d'un système d'animation très pratique, l'Animator. Il est composé d'animations et de transitions. Les transitions sont déclenchées par des conditions sur des variables. Les variables utilisées sont \emph{grounded} et \emph{moving}.

\emph{(Voir annexe [\ref{Animations}])}

\paragraph{Scripting de l'animation}
Cette partie est triviale car nous avons seulement à mettre à jour les variables au bon moment. La variable \emph{grounded} se modifie après que nous testons si le joueur touche sol. Quant à la variable \emph{moving}, celle-ci est mise à jour une fois que le joueur s'est déplacé et elle est obtenue à l'aide d'une autre variable nommée \emph{tangentSpeed}, c'est la norme de la vélocité projetée sur le plan horizontal, si cette valeur est supérieure à une limite, \emph{moving} est true, sinon false. Il y a une limite car le joueur n'est jamais à la vitesse 0 à cause de la friction (son mouvement peut être infime).

\begin{lstlisting}
// Squared tangent speed
float tangentSpeed = velocity.x * velocity.x + velocity.z * velocity.z;
\end{lstlisting}

\newpage
\subsubsection{À faire}

Voici les tâches à travailler avant la prochaine soutenance :

\begin{itemize}

\item Gameplay du joueur : Le joueur peut se déplacer correctement mais la plupart des événements ne sont pas synchronisés entre joueurs comme le statut.

\item Gameplay du jeu : Ici aussi, il faudra synchroniser les événements de jeu comme les phases, la partie la plus importante du jeu (sans elle il n'y a aucun gameplay).

\item Musique / Effets : Cette partie ne me semble pas prioritaire pour le moment mais une fois que les autres tâches auront été avancées, donner un peu plus de vie au jeu en rajoutant quelques effets pourrait s'avérer utile.

\end{itemize}

\subsubsection{Conclusion}

Pour conclure, je pensais pouvoir avancer un peu plus vite pour implémenter les phases du jeu mais il a été difficile de prévoir tous les événements réseau et nous avons préféré éviter les bugs lors de cette soutenance et présenter un jeu propre et sans vrai gameplay.
Pour la prochaine soutenance, le premier but sera d'avoir un gameplay en évitant les mauvaises synchronisations en réseau.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Leandre %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Léandre Perrot}
Dans ce projet, je suis principalement responsable de la génération aléatoire du terrain de jeu, des effets sonores et visuels, de la gestion du réseau et du gameplay global. Dans le cadre de cette soutenance, je me suis principalement concentré sur le terrain de jeu, étant donné qu'il s'agit du socle sur lequel reposent l'implémentation du réseau et les possibilités d'action des joueurs.

\subsubsection{Aleatoire}
Etant donné que la majorité des taches qui m'ont été dévolues nécessitent l'utilisation de variables aléatoires qui doivent être distinctes, j'ai dans un premier temps mis au point une fonction Aléatoire qui prend comme paramètre n, le nombre de valeurs souhaitées, et m, la valeur maximale. Par exemple, pour obtenir quatre valeurs aléatoires distinctes entre 0 et 10, il faudra rentre comme paramètres 4 et 11. Dans un premier temps, je crée deux listes : une de longueur n, remplie de -1, et une de longueur m, remplie de valeurs allant de 0 à m-1. Ensuite, pour chaque terme de la liste de longueur n, on prend une valeur aléatoire entre 0 et m-1, et on regarde dans la liste de longueur m si la valeur n'est pas -1. Si c'est -1, on effectue un parcours de la liste jusqu'à trouver une valeur différente de -1. On place ensuite la valeur dans la liste de longueur n, et on met à la place -1 dans la liste de longueur m. A la fin, la fonction retourne donc une liste de n éléments compris entre 0 et m (non inclus) qui sont tous distincts.

\subsubsection{Generation de la Carte}
J'aimerais évoquer l'algorithme que j'ai utilisé pour la génération du labyrinthe. L'objectif était de faire un dédale fermé, et avec à chaque fois plusieurs options pour passer d'un point A à un point B.

\paragraph{Organisation des données}
Dans un premier lieu, j'ai réfléchi à un moyen simple d'implémenter la variable du labyrinthe. Au final, j'ai opté pour l'utilisation d'une liste contenant autant d'éléments que le labyrinthe possède de salles. A la fin du traitement, on peut ainsi aisément déterminer les quatres murs du labyrinthes de cette manière :
\begin{itemize}
\item Nord : Il y a un mur au nord si la case est dans la rangée la plus au nord. Sinon, il y a un mur si la case directement au nord a une valeur impaire.
\item Ouest : Il y a un mur à l'ouest si la case est dans la rangée la plus à l'ouest. Sinon, il y a un mur si la case directement à l'ouest a une valeur strictement supérieure à 1.
\item Sud : Il y a un mur au sud si la valeur de la case est impaire.
\item Est : Il y a un mur à l'est si la valeur de la case est strictement supérieure à 1.
\end{itemize}
C'est avec cette implémentation que j'ai pu commencer à travailler sur la génération du dédale.

\paragraph{Implémentation}
Au début, j'ai comme paramètres xm et zm, qui correspondent aux nombres de salles présentes sur un coté du dédale. On instancie alors une liste Plan de taille xm * zm, et on la remplit de -1.
Ensuite, on fait un simple parcours de la liste à partir de la case à l'extrême nord-ouest. A chaque fois que l'on tombe sur une case ayant une valeur -1, cela signifie que cette case n'a pas encore été "visitée". Si ce n'est pas la première case, on relie la case actuelle aux cases déjà "visitées". Pour cela, si la case se trouve dans la rangée la plus au nord, on crée un mur vers l'ouest, et sinon, on creuse un mur vers le nord. Ensuite, on creuse un "chemin", c'est-à-dire que l'on va connecter des salles à la case actuelle. Pour ce faire, à chaque case, je crée une liste de quatre éléments (0 à 3) ordonnés aléatoirement. Ces éléments correspondent à l'ordre de priorité des directions à prendre. Pour chaque direction, je vérifie que la case ciblée n'est pas hors du labyrinthe, et qu'elle ne fait pas partie du "chemin" actuel. La première case correspondant à ces deux critères devient la nouvelle case actuelle : on creuse un mur entre elle et la salle précédente, et on continue. Si la case est déjà visitée, on arrete le chemin ici et on continue le parcours de la liste. Et si aucune direction ne permet d'obtenir une case valable, alors on arrete net le chemin sans creuser de mur (c'est ce qui forme les impasses). On peut ainsi obtenir un labyrinthe convenable, correspondant aux deux critères énoncés précedemment.
En réalité, cet algorithme à base de "chemin" existait déjà sous le nom d'algorithme de Prim, mais je n'étais pas du tout au courant de son existence lorsque j'ai élaboré celui-ci.

Mais cet algorithme que je viens de vous décrire présente un léger soucis : on peut voir apparaître des "piliers", c'est à dire qu'on a un ensemble de quatres salles en carré qui sont toutes connectées les unes aux autres (excepté par les diagonales). Ce type de configuration n'est pas problématique en soit, mais cela faisait que l'on pouvait très bien se retrouver avec un dédale uniquement constitué de piliers, ce qui ne correspond pas aux attentes du jeu. J'ai donc, à l'issu de l'élaboration du premier dédale, relancé un second parcours de la liste afin de traquer les piliers. Dès que je dédecte un pilier, je demande une variable aléatoire entre 0 et 3, qui correspond à l'un des quatre passages du pilier. Je place alors un mur à cet emplacement, et je continue le parcours. Avec ce simple second parcours, on peut donc à coup sur obtenir des dedales propres et avec des murs à coup sûr.

\subsubsection{Generation du Terrain}
En ce qui concerne la génération du dédale en tant qu'objet en trois dimensions où évolueront les joueurs, j'effectue une simple lecture de la liste obtenue par la Génération de la Carte. Actuellement, il y a deux versions d'implémentations : l'une très basique constituée de blocs, la seconde évoquant plus un laboratoire avec des salles et des couloirs.

\paragraph{Première Version : Blocs}
Au début de l'implémentation, je déforme un cube nommé Base pour permettre de couvrir le sol du labyrinthe en fonction de ses dimensions. Je crée également les murs extérieurs nord et ouest en entier. Ensuite, j'effectue le parcours de la liste : a chaque case, je place un cube dans l'angle sud-est de l'emplacement de la case sur le terrain. Ensuite, si la valeur de la case est impaire, je rajoute un mur au sud, et si la valeur de la case est strictement supérieure à 1, je rajoute un mur à l'est. On obtient donc un labyrinthe sommaire en blocs, mais qui correspond parfaitement à la carte attendue. Le problème de cette implémentation est qu'elle ne permet pas vraiment la modification de l'aspect du dédale, ce qui pourrait poser problème par la suite. Néanmoins, elle peut être efficace à partir du moment où l'on ne se concentre que sur le réseau ou sur la vérification de la validité du dédale.

\paragraph{Seconde Version : Salles et Couloirs}
A chaque case, j'évalue combien de passages permettent l'accès à la salle, et leurs dispositions. A partir de là, je crée à l'emplacement lié à la position de la case un objet vide correspondant à un préfabriqué. Cette méthode, à l'inverse de la première version, permet de modifier l'apparence globale de l'intérieur du dédale grâce aux préfabriqués.

\paragraph{Les préfabriqués}
Il existe six préfabriqués en tout. L'Impasse, une salle avec un seul accès, les deux couloirs, l'un où les passages sont l'un en face de l'autre et le second où ils sont adjacents, les deux bifurcations, l'un sous la forme de salle, l'autre sous la forme d'un couloir en T, et le Carrefour, une salle avec quatre accès. Je peux aisément, à partir du nombre de passages et de leur disposition, déterminer quel préfabriqué employer et son orientation. De plus, pour éviter d'avoir un nombre trop important de salles, j'ai décidé de créer un booléen qui, en alternant, permet d'avoir en cas de bifurcation soit une salle, soit un couloir, ce qui réduit considérablement le taux de salles dans les souterrains du laboratoire. Actuellement, les préfabriqués sont dans des couleurs primaires, à savoir mauve pour les murs, vert pour les meubles (pour les salles) et rouge pour le sol. De plus, je n'ai pas encore mis de plafond aux préfabriqués, ce qui permet d'avoir une vue d'ensemble du dédale du dessus.

\paragraph{Joueurs et Sérums}
Il y a également un autre point important dans la génération du terrain : les sérums et les joueurs.
Lorsque le dédale est intégralement construit, je demande à la fonction Aléatoire une liste de 7 termes aléatoires distincts compris entre 0 et le nombre de cases dans le dédale.
Les trois premiers termes correspondent aux sérums, les quatre autres aux joueurs. Il me suffit alors de créer un objet vide correspondant au préfabriqué du sérum dans la case correspondant à la valeur donnée. Actuellement, les sérums flottent en l'air et sont ainsi directement visibles par le joueur, mais plus tard, lorsque j'aurai terminé de construire les salles et les couloirs, leur emplacement variera en fonction de l'environnement où ils se trouvent. Par exemple, si au centre d'une salle, il y a une grosse armoire, les joueurs ne pourront pas y accéder puisque le sérum sera coincé dans le mobilier. A l'inverse, si l'on instancie le sérum dans un angle de la pièce, dès qu'il y en aura un dans un couloir, il sera derrière le mur, et donc inaccessible.
Concernant l'implémentation des joueurs, Steve et moi y travaillons encore. Actuellement, nous tentons de faire apparaître les joueurs sur quatre socles distincts, à l'extérieur du dédale, afin d'éviter que les joueurs ne se retrouvent tous en même temps au même point, ce qui pourrait être une source considérable de bugs. Quand nous y parviendrons, il nous suffira d'affecter aux joueurs les quatres dernières valeurs de la liste aléatoire que nous utilisons déjà pour les sérums.

\subsubsection{Variables expérimentales}
Afin de faciliter les tests de réseau et de gameplay, j'ai créé deux variables à part, l'une pour un dédale prédéfini et l'autre pour des emplacements de sérums déjà déterminés. A partir du dédale formé, il sera donc possible de simuler des parties de tests pour vérifier que tout fonctionne, sans être freiné par le côté aléatoire du terrain. Vous pouvez voir ci-dessous deux images du labyrinthe, en fonction de la version d'implémentation du terrain :


\par\vspace{0.5cm}
\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.5\textwidth]{Blocs.PNG}
    \caption{Blocs}
    \label{Blocs}
\end{figure}{}

\par\vspace{0.5cm}
\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.5\textwidth]{Salles.PNG}
    \caption{Salles}
    \label{Salles}
\end{figure}{}




%%%%%%%%%%%%%%%%%%%%%% Steve %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% Conclu %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% Annexes %%%%%%%%%%%%%%%%%%%%%


 
\newpage
\subsection{Steve Suissa}


\subsubsection{Introduction}

L’une des forces de ce jeu est son réseau. A la différence de la majorité des autres projets qui se contente de créer une salle et de la rejoindre directement, nous avons décidé d’opter pour une solution plus complète permettant plus de contrôle sur le multijoueur. Nous avons implémenté plusieurs menus pour modifier les salles.

\subsubsection{Les Menus}

Le premier menu montre la liste des salles ouvertes avec leurs propriétés (nombre de joueurs max, et par la suite le nombre de joueurs dans la salle) auxquelles nous pouvons rejoindre en simplement cliquant dessus, et un bouton permettant d’en créer une.
Après cela, on est redirigé vers un autre menu ou l’on peut voir la liste des joueurs présents dans la salle. Il y’a aussi un bouton Ready (symbolisé par un R) qui permet de montrer qu’on est prêt à commencer la partie. A noter que l’hôte de jeu (celui qui a créée la salle) ne peut commencer la partie que si tout le monde est prêt. Il peut quand même cliquer sur le bouton “Commencer la partie” mais cela ne fonctionnera pas. En prenant en compte les nombreuses fonctionnalités du code, il serait impossible de tout le montrer mais voici coment nous créons les salles : 

\subsubsection{Les RPC fonctions}

Ce système utilise des RPC fonctions. Ce sont des fonctions propres au multijoueur (dans notre cas Photon, le plugin que l’on utilise pour le multijoueur sur Unity) qui peuvent être représentées comme des messages qui sont véhiculés entre les différents joueurs. Chacune de ces fonctions est identifiée grâce à une clef, dans notre cas ce sera une chaine de caractere. Nous avons utilisé cette mécanique pour savoir si tous les joueurs étaient prêts ou non.

\newpage
\begin{lstlisting}
        public void OnClick_ReadyUp()
        {
            if (!PhotonNetwork.IsMasterClient)
            {
                SetReadyUp(!_ready);
                base.photonView.RPC("RPC_ChangeReadyState", RpcTarget.MasterClient, PhotonNetwork.LocalPlayer, _ready);
            }
        }
        
        [PunRPC]
        private void RPC_ChangeReadyState(Photon.Realtime.Player player, bool ready)
        {
            int index = _listings.FindIndex(x => x.Player == player);
            if (index != -1)
            {
                _listings[index].Ready = ready;
            }
        }
\end{lstlisting}

\subsubsection{Les CustomProprieties}

Nous avons aussi créés un prototype de propriétés personnalisables à chacun des joueurs. Ce système permet de montrer certaines propriétés (que l’on appelle CustomProprieties) propres à l'utilisateur (actuellement un identifiant, mais par la suite un avatar). Nous pouvons utiliser ce système dès le premier menu en cliquant sur le nombre pour lui affecter une valeur aléatoire de 0 à 99 et qui sera visible par les autres joueurs dans la salle.

Notre réseau permet aussi de détecter les états de connection des joueurs et savoir exactement s’ils sont connectés ou non, prêts ou pas, connecté à Internet etc...
\newpage
\begin{lstlisting}
public class RandomCustomPropertyGenerator : MonoBehaviour
{
    [SerializeField] 
    private Text _text;
    
    private ExitGames.Client.Photon.Hashtable _myCustomProperties = new ExitGames.Client.Photon.Hashtable();

    private void SetCustomNumber()
    {
        System.Random rnd = new System.Random();
        int result = rnd.Next(0, 99);

        _text.text = result.ToString();

        _myCustomProperties["RandomNumber"] = result;
        PhotonNetwork.SetPlayerCustomProperties(_myCustomProperties);
    }
    public void OnClick_Button()
    {
        SetCustomNumber();
    }
}
\end{lstlisting}

Dans ce cas précis, lorsque l'on clique sur le bouton le nombre aléatoire est crée et rajouté dans le texte

\subsubsection{Les ScriptableObjects}

Pour simplifier les scripts nous avons décidé de créer des ScriptableObjects qui permettent d’assigner un script à un GameObject de Unity plus facilement. Nous avons créé deux assets : GameSettings et MasterManager, le premier sert à stocker les propriétés du jeu (la version du jeu, la manière dont les noms des joueurs sont stockés etc…), et le second permet d’instancier les options du GameSettings. 4 scripts sont utilisés pour les ScriptableObjects : GameSettings, MasterManager, ScriptableObjectSingleton et SingletonReferences. Les deux premiers viennent d’être expliqués et les deux seconds permettent de détecter s’il y’a une erreur dans l’objet et sinon de l'instancier et de l'exécuter.
\newpage
\begin{lstlisting}
public class GameSettings : ScriptableObject
    {
        [SerializeField]
        private string _gameVersion = "0.0.0";

        public string GameVersion => _gameVersion;
        [SerializeField]
        private string _nickname = "Joueur";

        public string Nickname
        {
            get
            {
                int value = Random.Range(0, 9999);
                return _nickname + value.ToString();
            }
        }
\end{lstlisting}

\begin{lstlisting}
 public static T Instance
        {
            get
            {
                if (_instance == null)
                {
                    T[] results = Resources.FindObjectsOfTypeAll<T>();
                    if (results.Length == 0)
                    {
                        Debug.LogError("SingletonScriptableObject -> Instance -> results length is 0 for type " + typeof(T).ToString() + ".");
                        return null;
                    }
                    if (results.Length > 1)
                    {
                        Debug.LogError("SingletonScriptableObject -> Instance -> results length is greather than 1 for type " + typeof(T).ToString() + ".");
                        return null;
                    }

                    _instance = results[0];
                }
                return _instance;
            }
        }
\end{lstlisting}



\subsubsection{Les Photon Views}

Les Photons Views sont des composants de Photon qui permettent d’observer le réseau. Ils permettent de synchroniser la taille, la rotation et la position de l’objet dans le réseau. Il faut veiller à ce que la Photon View soit propre à la scène (contrôlé par l’hôte de jeu) ou par un joueur spécifique pour ne pas avoir de doublons ou des objets invisibles.
Ils sont sous plusieurs formes : Transform pour les objets simples, RigidBody (2D ou pas) qui permet de gérer directement la physique de l’objet etc… Nous utiliserons le Photon View Animator permettant en plus de synchroniser l’animation des personnages en temps réel.


\section{Conclusion}

En ce qui concerne la prochaine soutenance, le jeu devrait être jouable et nous devrions avoir implémenté des bruitages sonores et de la musique au jeu. De plus, les graphismes devront être modifiés pour un meilleur ressenti d’un point de vue du joueur. Enfin, le site devrait déjà avoir une forme bien plus esthétique. Cela nous laissera plus de temps pour avancer sur des bonus vu que l'essentiel du jeu sera déjà là.


\newpage
\section{Annexes}


%%%%%% Celian %%%%%
\subsection{Célian}
\subsubsection{Mouvements}
\label{Mouvements}
\begin{lstlisting}
// If input and (not max speed or braking)
if (movements.sqrMagnitude > .1 &&
    (tangentSpeed < maxSpeed * maxSpeed * speedFactor * speedFactor ||
    velocity.x * movements.x + velocity.z * movements.z < 0))
        velocity += movements * Time.deltaTime * speedFactor;
\end{lstlisting}

\subsubsection{Friction}
\label{Friction}
\begin{lstlisting}
// Friction
if (grounded)
{
    velocity.x -= velocity.x * Time.deltaTime * friction;
    velocity.z -= velocity.z * Time.deltaTime * friction;
}
else
{
    velocity.x -= velocity.x * Time.deltaTime * damping;
    velocity.z -= velocity.z * Time.deltaTime * damping;
}
\end{lstlisting}


\subsubsection{Réseau (A)}
\label{NetA}
\begin{lstlisting}
// Ce code est raccourci

// The player controlled by the client
public static Player localPlayer;

// List of all players (as GameObject)
public static List<GameObject> Players;

// Registers a new player in the players list
public static void RegisterPlayer(GameObject p)
{
    // Update the player list
    players.Add(p);

    if (players.Count == PhotonNetwork.PlayerList.Length)
        // Dispatch events
        OnAllPlayersInGame();
}
\end{lstlisting}


\subsubsection{Réseau (B)}
\label{NetB}
\begin{lstlisting}
// When the player controlled by the client hits another player
void OnControllerColliderHit(ControllerColliderHit hit)
{
    // The player collides another player
    // This player must send the event
    if (net.HasPriority(pNet))
    {
        // This player is infected
        if (state.Status == PlayerState.PlayerStatus.HEALED &&
            pState.Status == PlayerState.PlayerStatus.INFECTED)
            PlayerNetwork.SendPlayerStatusSet(net.id, PlayerState.PlayerStatus.INFECTED);
        // The other player is infected
        else if (pState.Status == PlayerState.PlayerStatus.HEALED &&
            state.Status == PlayerState.PlayerStatus.INFECTED)
            PlayerNetwork.SendPlayerStatusSet(pNet.id, PlayerState.PlayerStatus.INFECTED);
    }
}
\end{lstlisting}


\subsubsection{Phases}
\label{PhaseA}
\begin{lstlisting}
public enum PlayerStatus
{
    INFECTED,
    HEALED,
    CORRUPTED,
    GHOST
}

public PlayerStatus Status
{
    set
    {
        // Update status
        status = value;

        // Change label
        if (player && player.nameUi)
            player.nameUi.SetStatus(status);

        // Update material / play sound...
        switch (status)
        {
            case PlayerStatus.HEALED:
                Debug.Log("Player has status HEALED");
                break;
            case PlayerStatus.INFECTED:
                Debug.Log("Player has status INFECTED");
                break;
        }
    }
}
\end{lstlisting}

\subsubsection{Animations}
\label{Animations}

\begin{figure}[h]
	\includegraphics[width=1\textwidth]{anim.jpg}
	\caption{Schéma d'animations}
\end{figure}


\end{document}










%%% TODO :
% Certaines partie de code sont non colorisees


